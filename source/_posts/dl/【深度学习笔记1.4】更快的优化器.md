---
title: 【深度学习笔记1.4】更快的优化器
date: 2017-11-22 17:28:05
tags:
categories: ["深度学习笔记"]
mathjax: true
---

## 概述

&emsp; 训练一个非常大的深度神经网络可能会非常缓慢。 到目前为止，我们已经看到了四种加速训练的方法：对连接权重应用良好的初始化策略，使用良好的激活函数，使用批量规范化以及重用预训练网络的部分。另一个巨大的速度提升来自使用比普通渐变下降优化器更快的优化器。 在本节中，我们将介绍最流行的：动量优化，Nesterov 加速梯度，AdaGrad，RMSProp，最后是 Adam 优化。
<!-- more -->

&emsp; 剧透：本节的结论是，您几乎总是应该使用Adam_optimization，只需要这么小的改动，训练通常会快几倍。Adam 优化有三个可以调整的超参数（加上学习率）。 默认值通常工作的不错，但如果您需要调整它们，知道他们怎么实现的可能会有帮助。 Adam 优化结合了来自其他优化算法的几个想法，所以先看看这些算法是有用的。


## 动量优化（Momentum optimization）
&emsp; 如果把梯度下降法想象成一个小球从山坡到山谷的过程，那么梯度下降的小球是这样移动的：从A点开始，计算当前A点的坡度，沿着坡度最大的方向走一步到B点，在B点再看一看周围坡度最大的地方，沿着这个坡度方向再走一步后到C点。确切的来说，这并不像一个球，更像是一个正在下山的盲人，每走一步都要停下来，用拐杖来来探探四周的路，再走一步停下来，周而复始，直到走到山谷。而一个真正的小球要比这聪明多了，从A点滚动到B点的时候，小球带有一定的初速度，在当前初速度下继续加速下降，小球会越滚越快，更快的奔向谷底。动量法就是模拟这一过程来加速神经网络优化的[1]。（动量优化由Boris Polyak 在 1964年提出）

![enter image description here](https://lh3.googleusercontent.com/-IXbxcKq8DqM/XBJBx1mH2kI/AAAAAAAAAKI/6DsNehf43-0XT7gul9wz5d_qXxtwr23HgCLcBGAs/s0/%25E5%258A%25A8%25E9%2587%258F%25E4%25BC%2598%25E5%258C%25961.jpg "动量优化1.jpg")
<center>图1. 动量优化直观图解</center>
上图直观的解释了动量法的全部内容。

梯度下降权重$\theta$的更新方程是$\boldsymbol \theta := \boldsymbol \theta - \eta \nabla_\boldsymbol\theta J(\boldsymbol \theta)$，它不关心早期的梯度是什么。如果局部梯度很小，则会非常缓慢。

**Momentum梯度下降权重 $\boldsymbol\theta$ 更新规则如下**：
$$
\begin{array} \
\boldsymbol v_t = \gamma \boldsymbol v_{t-1} + \eta \nabla_ \boldsymbol \theta \\
\boldsymbol \theta \leftarrow \boldsymbol \theta - \boldsymbol v_t
\end{array} \
$$

这里的 $\boldsymbol v$ 为动量矢量，为了模拟某种摩擦机制[2]，避免动量过大，该算法引入了一个新的超参数 $\gamma$，它必须设置在 0（高摩擦）和 1（无摩擦）之间（$0≤\gamma<1$）[3]，典型的取值是 0.9。

![enter image description here](https://lh3.googleusercontent.com/-ZQb7f3TIjck/XBJN9TRND-I/AAAAAAAAAKY/OaN5uLOpcX44gIWNvkJIndJ6G1PiWS-TgCLcBGAs/s0/%25E5%258A%25A8%25E9%2587%258F%25E4%25BC%2598%25E5%258C%25962.png "动量优化2.png")
<center>图2. SGD with momentum or not</center>

&emsp; SGD在ravines(沟谷)很容易被困住，如图2左图所示，这时候SGD来回震荡而缓慢接近极小值，Momentum 通过加入 $\eta \boldsymbol v_{t-1}$ 这一项，这使得当 $t$ 时刻梯度方向和 $(t-1)$ 时刻相近时速度加快，当$t$ 时刻梯度方向有所改变时更新速度变慢，这样可以加快收敛并减小震荡，如图2右图所示。

> (me)由 Momentum 可以联想到速度公式 $v_t = v_{t-1} + at$，只不过Momentum为了避免动量 $\boldsymbol v_t$ 过大，从而引入了超参数 $\gamma$，而Momentum中的 $\eta \nabla_\boldsymbol \theta J(\boldsymbol \theta)$ 则相当于 $at$，为当前时刻新增加的动量。

*下面这段话来自文献[2]，但我没看懂这部分内容。该内容在文献[3]中也有所提及。*
<font color=#ff0000>*如果梯度保持不变，则最终速度（即，权重更新的最大大小）等于该梯度乘以学习率η乘以1/(1-β)。 例如，如果β = 0.9，则最终速度等于学习率的梯度乘以 10 倍，因此动量优化比梯度下降快 10 倍[2]！*</font>

> 在不使用Batch Normalization的深层神经网络中，较高层往往会得到具有不同的尺度的输入，所以使用动量优化会有很大的帮助。 它也可以帮助滚过局部最优值[2]。

&emsp; 在 TensorFlow 中实现动量优化是一件简单的事情：只需用MomentumOptimizer替换GradientDescentOptimizer.
```python
optimizer = tf.train.MomentumOptimizer(learning_rate=learning_rate, momentum=0.9)
```

## Nesterov加速梯度（Nesterov Accelerated Gradient）
&emsp; Yurii Nesterov 在 1983 年提出的动量优化的一个小变体几乎总是比普通的动量优化更快。 Nesterov 动量优化（Nesterov Momentum Optimization）或 Nesterov 加速梯度（Nesterov Accelerated Gradient，NAG）的思想是测量损失函数的梯度不是在局部位置，而是在动量方向稍微靠前（见公式 11-5）。 与普通的动量优化的唯一区别在于梯度是在θ+βm而不是在θ处测量的。

**Nesterov Momentum Optimization权重 $\boldsymbol\theta$ 更新规则如下**：
$$
\begin{array} \
\boldsymbol v_t = \gamma \boldsymbol v_{t-1} + \eta \nabla_ \boldsymbol \theta J(\boldsymbol \theta + \gamma \boldsymbol v_{t-1}) \\
\boldsymbol \theta \leftarrow \boldsymbol \theta - \boldsymbol v_t
\end{array} \
$$

在 TensorFlow 中要使用NAG，只需在创建MomentumOptimizer时设置use_nesterov = True 即可：
```python
optimizer = tf.train.MomentumOptimizer(learning_rate=learning_rate, momentum=0.9, use_nesterov=True)
```


## AdaGrad
&emsp; Adagrad 算法根据自变量在每个维度的梯度值的大小来调整各个维度上的学习率，从而避免统一的学习率难以适应所有维度的问题 [3]。
**AdaGrad权重 $\boldsymbol\theta$ 更新规则如下**：
$$
\begin{array} \
\boldsymbol s_t = \gamma \boldsymbol s_{t-1} + \eta \nabla_ \boldsymbol \theta J(\boldsymbol \theta) \odot \nabla_ \boldsymbol \theta J(\boldsymbol \theta) \\
\boldsymbol \theta \leftarrow \boldsymbol \theta - \dfrac{\eta}{\sqrt{\boldsymbol s_t + \epsilon}} \odot \nabla_ \boldsymbol \theta J(\boldsymbol \theta) 
\end{array} \
$$
其中$\odot$表示按元素相乘，$\eta$是学习率，$\epsilon$是避免被零除的平滑项，通常设置为$10^{-10}$.
> AdaGrad论文：“Adaptive Subgradient Methods for Online Learning and Stochastic Optimization,” J. Duchi et al. (2011).


&emsp; 这种算法会降低学习速度，但对于陡峭的地方(常出现在迭代初期)，其速度要快于具有温和坡度处。这被称为自适应学习率。另一个好处是它不需要那么多的去调整学习率超参数η [2]。

&emsp; 需要强调的是，小批量随机梯度按元素平方的累加变量 st 出现在学习率的分母项中。因此，如果目标函数有关自变量中某个元素的偏导数一直都较大，那么该元素的学习率将下降较快；反之，如果目标函数有关自变量中某个元素的偏导数一直都较小，那么该元素的学习率将下降较慢。然而，由于 st 一直在累加按元素平方的梯度，自变量中每个元素的学习率在迭代过程中一直在降低（或不变）。所以，当学习率在迭代早期降得较快且当前解依然不佳时，Adagrad 在迭代后期由于学习率过小，可能较难找到一个有用的解[3]。

&emsp; 对于简单的二次问题，AdaGrad 经常表现良好，但不幸的是，在训练神经网络时，它经常停止得太早。 学习率被缩减得太多，以至于在达到全局最优之前，算法完全停止。 所以，即使 TensorFlow 有一个AdagradOptimizer，你也不应该用它来训练深度神经网络（虽然对线性回归这样简单的任务可能是有效的）[2]。


## RMSProp
&emsp; 当学习率在迭代早期降得较快且当前解依然不佳时，Adagrad 在迭代后期由于学习率过小，可能较难找到一个有用的解。为了应对这一问题，RMSProp 算法对 Adagrad 做了一点小小的修改。

>>>>>>>> 需要用到加权移动平均，文献[3]中的动量法提到了这些东西，可以先看看文献[3]中动量法的加权移动平均。




## 参考文献
[1] [深度学习优化函数详解（4）-- momentum 动量法](https://blog.csdn.net/tsyccnh/article/details/76270707)
[2] [hands_on_Ml_with_Sklearn_and_TF.第10章.训练深层神经网络. 更快的优化器](https://github.com/apachecn/hands_on_Ml_with_Sklearn_and_TF/blob/dev/docs/11.%E8%AE%AD%E7%BB%83%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.md)
[3] [动手学深度学习.优化算法](https://zh.gluon.ai/chapter_optimization/index.html)
