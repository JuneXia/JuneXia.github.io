---
title: 【深度学习笔记1.3】复用预训练层
date: 2017-10-13 17:28:05
tags:
categories: ["深度学习笔记"]
mathjax: true
---

## 概述
&emsp; 从零开始训练一个非常大的 DNN 通常不是一个好主意，相反，您应该总是尝试找到一个现有的神经网络来完成与您正在尝试解决的任务类似的任务，然后复用这个网络的较低层：这就是所谓的迁移学习。这不仅会大大加快训练速度，还将需要更少的训练数据[1]。
<!-- more -->

&emsp; 例如，假设您可以访问经过训练的 DNN，将图片分为 100 个不同的类别，包括动物，植物，车辆和日常物品。 您现在想要训练一个 DNN 来对特定类型的车辆进行分类。 这些任务非常相似，因此您应该尝试重新使用第一个网络的一部分（请参见图1）[1]。
<center>![enter image description here](https://lh3.googleusercontent.com/-QDchB78as70/XAyEgyKDSwI/AAAAAAAAAJo/qDktP3BJrdkgufRGBE360FPO15Pl3pDwQCLcBGAs/s0/%25E5%25A4%258D%25E7%2594%25A8%25E9%25A2%2584%25E8%25AE%25AD%25E7%25BB%2583%25E5%25B1%2582.png "复用预训练层.png")</center>
<center>图1. 复用预训练层</center>

&emsp; 如果新任务的输入图像与原始任务中使用的输入图像的大小不一致，则必须添加预处理步骤以将其大小调整为原始模型的预期大小。 更一般地说，如果输入具有类似的低级层次的特征，则迁移学习将很好地工作[1]。

## 1. 复用 TensorFlow 模型
为了代码的可调试性，下面先给出原模型的完整训练代码。

### 1.1 原模型完整训练代码

代码示例1：
mnist_dnn5.py
```
import os
import datetime
import tensorflow as tf
import numpy as np
from tensorflow.examples.tutorials.mnist import input_data

datapath = "/home/***/res/MNIST_data"
mnist = input_data.read_data_sets(datapath, validation_size=0, one_hot=True)
model_field = "mnist_dnn5"
save_path = "./mnist_models/" + model_field + '_' + datetime.datetime.now().strftime('%Y%m%d%H%M%S')
if os.path.exists(save_path) is not True:
    os.mkdir(save_path)

n_inputs = 28 * 28
n_hidden1 = 300
n_hidden2 = 50
n_hidden3 = 50
n_hidden4 = 50
n_hidden5 = 50
n_outputs = 10

learning_rate = 0.01
n_epoches = 20
batch_size = 200

X = tf.placeholder(tf.float32, shape=(None, n_inputs), name='X')
y = tf.placeholder(tf.int64, shape=None, name='y')

with tf.name_scope("dnn"):
    hidden1 = tf.layers.dense(X, n_hidden1, activation=tf.nn.relu, name="hidden1")
    hidden2 = tf.layers.dense(hidden1, n_hidden2, activation=tf.nn.relu, name="hidden2")

    hidden3 = tf.layers.dense(hidden2, n_hidden3, activation=tf.nn.relu, name="hidden3")
    hidden4 = tf.layers.dense(hidden3, n_hidden4, activation=tf.nn.relu, name="hidden4")
    hidden5 = tf.layers.dense(hidden4, n_hidden5, activation=tf.nn.relu, name="hidden5")

    logits = tf.layers.dense(hidden5, n_outputs, name="outputs")

with tf.name_scope("loss"):
    xentropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=logits)
    loss = tf.reduce_mean(xentropy, name="loss")

# 梯度裁剪
threshold = 1.0
optimizer = tf.train.GradientDescentOptimizer(learning_rate)
grads_and_vars = optimizer.compute_gradients(loss)
capped_gvs = [(tf.clip_by_value(grad, -threshold, threshold), var) for grad, var in grads_and_vars]  # 将梯度裁剪到 -1.0 和 1.0 之间
training_op = optimizer.apply_gradients(capped_gvs)

with tf.name_scope("eval"):
    correct = tf.nn.in_top_k(logits, y, 1)
    accuracy = tf.reduce_mean(tf.cast(correct, tf.float32), name="accuracy")

init = tf.global_variables_initializer()
saver = tf.train.Saver()

with tf.Session() as sess:
    init.run()
    for epoch in range(n_epoches):
        for iteraton in range(mnist.train.num_examples // batch_size):
            X_batch, y_batch = mnist.train.next_batch(batch_size)
            y_batch = np.argmax(y_batch, 1)

            sess.run(training_op, feed_dict={X: X_batch, y: y_batch})

        y_batch = np.argmax(mnist.test.labels, 1)
        accuracy_val = accuracy.eval(feed_dict={X: mnist.test.images, y: y_batch})
        print(epoch, 'Test accuracy:', accuracy_val)

    save_file = os.path.join(save_path, model_field + '.ckpt')
    save_path = saver.save(sess, save_file)
```

在mnist测试集上的准确率如下：
> 0 Test accuracy: 0.5471
1 Test accuracy: 0.8268
...
18 Test accuracy: 0.9595
19 Test accuracy: 0.9602


### 1.2 复用Tensorflow模型
&emsp; 如果原始模型使用 TensorFlow 进行训练，则可以简单地将其恢复并在新任务上进行训练。任务越相似，您可以重复使用的层越多（从较低层开始）。对于非常相似的任务，您可以尝试保留所有隐藏的层，只替换输出层[1]。


 - 将原始模型中每个变量的名称映射到新模型中
```
# 将原始模型中每个变量的名称映射到新模型中的名称（通常需要保持完全相同的名称）
pretrain_model = '/home/***/dev/handml/mnist_models/mnist_dnn5_20181208182059/mnist_dnn5.ckpt'

# build new model with the same definition as before for hidden layers 1-3
reuse_vars = tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES, scope="hidden[123]")  # regular expression
reuse_vars_dict = dict([(var.op.name, var) for var in reuse_vars])
restore_saver = tf.train.Saver(reuse_vars_dict)  # to restore layers 1-3
```


- 在session中恢复原模型
```
init = tf.global_variables_initializer()
saver = tf.train.Saver()  # 用于保存新的模型

with tf.Session() as sess:
    init.run()
    restore_saver.restore(sess, pretrain_model)

    for epoch in range(n_epoches):
        ...
        sess.run(training_op, feed_dict={X: X_batch, y: y_batch})
        ...

    save_path = saver.save(sess, "./mnist_models/new_model_reused_tmp.ckpt")
```

完整代码示例如下
代码示例2：
reuse\_tensorflow\_model.py
```
import os
import tensorflow as tf
import numpy as np
from tensorflow.examples.tutorials.mnist import input_data

datapath = "/home/***/res/MNIST_data"
mnist = input_data.read_data_sets(datapath, validation_size=0, one_hot=True)

ROOT_DIR = os.path.abspath('./')
pretrain_model = os.path.join(ROOT_DIR, 'mnist_models/mnist_dnn5_20181208182059/mnist_dnn5.ckpt')


n_inputs = 28 * 28   # MNIST
n_hidden1 = 300  # reused
n_hidden2 = 50   # reused
n_hidden3 = 50   # reused
n_hidden4 = 30   # new!
# n_hidden5 = 20   # new!
n_outputs = 10   # new!
# 预训练模型中有5个隐藏层，我们这里只有4个隐藏层，其中前3层是复用预训练模型的.

learning_rate = 0.01
n_epoches = 20
batch_size = 200

X = tf.placeholder(tf.float32, shape=(None, n_inputs), name="X")
y = tf.placeholder(tf.int64, shape=(None), name="y")

with tf.name_scope("dnn"):
    # 原始模型中每个变量的名称应当和新模型中的名称保持完全相同
    hidden1 = tf.layers.dense(X, n_hidden1, activation=tf.nn.relu, name="hidden1")        # reused
    hidden2 = tf.layers.dense(hidden1, n_hidden2, activation=tf.nn.relu, name="hidden2")  # reused
    hidden3 = tf.layers.dense(hidden2, n_hidden3, activation=tf.nn.relu, name="hidden3")  # reused
    hidden4 = tf.layers.dense(hidden3, n_hidden4, activation=tf.nn.relu, name="hidden4")  # new!
    # hidden5 = tf.layers.dense(hidden4, n_hidden5, activation=tf.nn.relu, name="hidden5")  # new!
    logits = tf.layers.dense(hidden4, n_outputs, name="outputs")                          # new!

with tf.name_scope("loss"):
    xentropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=logits)
    loss = tf.reduce_mean(xentropy, name="loss")

with tf.name_scope("eval"):
    correct = tf.nn.in_top_k(logits, y, 1)
    accuracy = tf.reduce_mean(tf.cast(correct, tf.float32), name="accuracy")

with tf.name_scope("train"):
    optimizer = tf.train.GradientDescentOptimizer(learning_rate)
    training_op = optimizer.minimize(loss)

# build new model with the same definition as before for hidden layers 1-3
reuse_vars = tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES, scope="hidden[123]")  # regular expression
reuse_vars_dict = dict([(var.op.name, var) for var in reuse_vars])
restore_saver = tf.train.Saver(reuse_vars_dict)  # to restore layers 1-3

init = tf.global_variables_initializer()
saver = tf.train.Saver()  # 用于保存新的模型

with tf.Session() as sess:
    init.run()
    restore_saver.restore(sess, pretrain_model)

    for epoch in range(n_epoches):
        for iteration in range(mnist.train.num_examples // batch_size):
            X_batch, y_batch = mnist.train.next_batch(batch_size)
            y_batch = np.argmax(y_batch, 1)

            sess.run(training_op, feed_dict={X: X_batch, y: y_batch})

        y_batch = np.argmax(mnist.test.labels, 1)
        accuracy_val = accuracy.eval(feed_dict={X: mnist.test.images, y: y_batch})
        print(epoch, "Test accuracy:", accuracy_val)

    save_path = saver.save(sess, "./mnist_models/new_model_reused_tmp.ckpt")
```

> 0 Test accuracy: 0.918
1 Test accuracy: 0.9396
...
18 Test accuracy: 0.9664
19 Test accuracy: 0.9665


## 2. 复用来自其它框架的模型
&emsp; 如果模型是使用其他框架进行训练的，则需要手动加载权重（例如，如果使用 Theano 训练，则使用 Theano 代码），然后将它们分配给相应的变量，这部分可参考文献[1]。


## 3. 冻结较低层（Freezing the Lower Layers）
&emsp; 第一个 DNN 的较低层可能已经学会了检测图片中的低级特征，这将在两个图像分类任务中有用，因此您可以按照原样重新使用这些层。 在训练新的 DNN 时，“冻结”权重通常是一个好主意：如果较低层权重是固定的，那么较高层权重将更容易训练（因为他们不需要学习一个移动的目标）。 要在训练期间冻结较低层，最简单的解决方案是给优化器列出要训练的变量，不包括来自较低层的变量[1]：
```
train_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope="hidden[34]|outputs")  # regular expression
    training_op = optimizer.minimize(loss, var_list=train_vars)
```

> 注意：这里的“冻结较低层”和第1节中介绍的“复用Tensorflow模型”中的方法不一样，“复用Tensorflow模型”是指将pretained\_model中某些层复制到新模型中，在训练的过程中这些层会被更新，而“冻结较低层”是指将pretained\_model中较低层复制到新模型中并冻结住，即在训练过程中这些层不会被更新。

## 4. 缓存冻结层（Caching the Frozen Layers）
&emsp; 由于冻结层不会改变，因此可以为每个训练实例缓存最上面的冻结层的输出。 由于训练贯穿整个数据集很多次，这将给你一个巨大的速度提升，因为每个训练实例只需要经过一次冻结层（而不是每个迭代一次）。 例如，你可以先运行整个训练集（假设你有足够的内存）[1]：
```
hidden2_outputs = sess.run(hidden2, feed_dict={X: X_train})
```

然后在训练过程中，不再对训练实例建立批次，而是从隐藏层2的输出建立批次，并将它们提供给训练操作：
```
import numpy.random as rnd

with tf.Session() as sess:
    init.run()
    restore_saver.restore(sess, pretrain_model)

    X_train = mnist.train.images
    y_train = mnist.train.labels
    hidden2_outputs = sess.run(hidden2, feed_dict={X: X_train})
    for epoch in range(n_epoches):
        shuffled_idx = rnd.permutation(len(hidden2_outputs))
        hidden2_batches = np.array_split(hidden2_outputs[shuffled_idx], batch_size)
        y_batches = np.array_split(y_train[shuffled_idx], batch_size)
        for hidden2_batch, y_batch in zip(hidden2_batches, y_batches):
            y_batch = np.argmax(y_batch, 1)
            sess.run(training_op, feed_dict={hidden2: hidden2_batch, y: y_batch})
```

综合第3、4节，完整代码示例如下。
代码示例3：
Freezing\_the\_LowerLayers.py
```
import os
import tensorflow as tf
import numpy as np
import numpy.random as rnd
from tensorflow.examples.tutorials.mnist import input_data

datapath = '/home/***/res/MNIST_data'
mnist = input_data.read_data_sets(datapath, validation_size=0, one_hot=True)

ROOT_DIR = os.path.abspath('./')
pretrain_model = os.path.join(ROOT_DIR, 'mnist_models/mnist_dnn5_20181208182059/mnist_dnn5.ckpt')


n_inputs = 28 * 28   # MNIST
n_hidden1 = 300  # reused
n_hidden2 = 50   # reused
n_hidden3 = 50   # reused
n_hidden4 = 30   # new!
# n_hidden5 = 20   # new!
n_outputs = 10   # new!

learning_rate = 0.01
n_epoches = 20
batch_size = 200

X = tf.placeholder(tf.float32, shape=(None, n_inputs), name="X")
y = tf.placeholder(tf.int64, shape=(None), name="y")

with tf.name_scope("dnn"):
    # 原始模型中每个变量的名称应当和新模型中的名称保持完全相同
    hidden1 = tf.layers.dense(X, n_hidden1, activation=tf.nn.relu, name="hidden1")        # reused
    hidden2 = tf.layers.dense(hidden1, n_hidden2, activation=tf.nn.relu, name="hidden2")  # reused
    hidden3 = tf.layers.dense(hidden2, n_hidden3, activation=tf.nn.relu, name="hidden3")  # reused
    hidden4 = tf.layers.dense(hidden3, n_hidden4, activation=tf.nn.relu, name="hidden4")  # new!
    # hidden5 = tf.layers.dense(hidden4, n_hidden5, activation=tf.nn.relu, name="hidden5")  # new!
    logits = tf.layers.dense(hidden4, n_outputs, name="outputs")                          # new!

with tf.name_scope("loss"):
    xentropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=y, logits=logits)
    loss = tf.reduce_mean(xentropy, name="loss")

with tf.name_scope("eval"):
    correct = tf.nn.in_top_k(logits, y, 1)
    accuracy = tf.reduce_mean(tf.cast(correct, tf.float32), name="accuracy")

with tf.name_scope("train"):
    optimizer = tf.train.GradientDescentOptimizer(learning_rate)
    # training_op = optimizer.minimize(loss)

    # 冻结较低层
    train_vars = tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES, scope="hidden[34]|outputs")  # regular expression
    training_op = optimizer.minimize(loss, var_list=train_vars)

# build new model with the same definition as before for hidden layers 1-3
reuse_vars = tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES, scope="hidden[123]")  # regular expression
reuse_vars_dict = dict([(var.op.name, var) for var in reuse_vars])
restore_saver = tf.train.Saver(reuse_vars_dict)  # to restore layers 1-3

init = tf.global_variables_initializer()
saver = tf.train.Saver()  # 用于保存新的模型

with tf.Session() as sess:
    init.run()
    restore_saver.restore(sess, pretrain_model)

    X_train = mnist.train.images
    y_train = mnist.train.labels
    hidden2_outputs = sess.run(hidden2, feed_dict={X: X_train})
    for epoch in range(n_epoches):
        shuffled_idx = rnd.permutation(len(hidden2_outputs))
        hidden2_batches = np.array_split(hidden2_outputs[shuffled_idx], batch_size)
        y_batches = np.array_split(y_train[shuffled_idx], batch_size)
        for hidden2_batch, y_batch in zip(hidden2_batches, y_batches):
            y_batch = np.argmax(y_batch, 1)
            sess.run(training_op, feed_dict={hidden2: hidden2_batch, y: y_batch})

        y_batch = np.argmax(mnist.test.labels, 1)
        accuracy_val = accuracy.eval(feed_dict={X: mnist.test.images, y: y_batch})
        print(epoch, "Test accuracy:", accuracy_val)

    save_path = saver.save(sess, "./mnist_models/new_model_reused_tmp.ckpt")
```

> 0 Test accuracy: 0.9033
1 Test accuracy: 0.9344
...
18 Test accuracy: 0.9572
19 Test accuracy: 0.9562


## 5. 调整，删除或替换较高层

原始模型的输出层通常应该被替换，因为对于新的任务来说，最有可能没有用处，甚至可能没有适合新任务的输出数量。

类似地，原始模型的较高隐藏层不太可能像较低层一样有用，因为对于新任务来说最有用的高层特征可能与对原始任务最有用的高层特征明显不同。 你需要找到正确的层数来复用。

尝试先冻结所有复制的层，然后训练模型并查看它是如何执行的。 然后尝试解冻一个或两个较高隐藏层，让反向传播调整它们，看看性能是否提高。 您拥有的训练数据越多，您可以解冻的层数就越多。

如果仍然无法获得良好的性能，并且您的训练数据很少，请尝试删除顶部的隐藏层，并再次冻结所有剩余的隐藏层。 您可以迭代，直到找到正确的层数重复使用。 如果您有足够的训练数据，您可以尝试替换顶部的隐藏层，而不是丢掉它们，甚至可以添加更多的隐藏层。


## 6. Model Zoos
&emsp; 你在哪里可以找到一个类似于你想要解决的任务训练的神经网络？ 首先看看显然是在你自己的模型目录。 另一个选择是在模型动物园中搜索。 许多人为了各种不同的任务而训练机器学习模型，并且善意地向公众发布预训练模型。
&emsp; TensorFlow 在 https://github.com/tensorflow/models 中有自己的模型动物园，另一个流行的模型动物园是 Caffe 模型动物园。Saumitro Dasgupta 写了一个转换器，可以在 https://github.com/ethereon/caffetensorflow看到。


## 7. 无监督的预训练（Unsupervised Pretraining）
&emsp; 假设你想要解决一个复杂的任务，不幸的是，你既没有太多已标记的训练数据，也不能找到一个类似的任务训练模型。不要失去所有希望！首先，你当然应该尝试收集更多的有标签的训练数据，但是如果这太难或太昂贵，你仍然可以进行无监督的训练（见图2）。也就是说，如果你有很多未标记的训练数据，你可以尝试逐层训练层，从最低层开始，然后上升，使用无监督的特征检测算法，如限制玻尔兹曼机（RBM；见附录 E）或自动编码器（见第 15 章）。每个层都被训练成先前训练过的层的输出（除了被训练的层之外的所有层都被冻结）。一旦所有层都以这种方式进行了训练，就可以使用监督式学习（即反向传播）对网络进行微调。

![enter image description here](https://lh3.googleusercontent.com/-p2BUjG52sQw/XA-9GZqjqgI/AAAAAAAAAJ4/08m7-8ak8RY8H-PvCj9ouC63p8rlZ7gqQCLcBGAs/s0/%25E5%25A4%258D%25E7%2594%25A8%25E9%25A2%2584%25E8%25AE%25AD%25E7%25BB%2583%25E5%25B1%25822.png "复用预训练层2.png")
<center>图2. 无监督的预训练</center>

&emsp; 这是一个相当漫长而乏味的过程，但通常运作良好。 实际上，这是 Geoffrey Hinton 和他的团队在 2006 年使用的技术，导致了神经网络的复兴和深度学习的成功。 实际上，无监督预训练（通常使用 RBM）一直是深度网络的标准，直到 2010 年，在梯度消失问题得到缓解之后，纯训练 DNN 才更为普遍。然而，当您有一个复杂的任务需要解决，且没有类似的模型可以重复使用、标记的训练数据又很少、但是大量的未标记的训练数据时，无监督训练（现在通常使用自动编码器而不是 RBM）仍然是一个很好的选择。




## 8. 在辅助任务上预训练（Pretraining on an Auxiliary Task）
&emsp; 最后一种选择是在辅助任务上训练第一个神经网络，然后重新使用该网络的较低层来完成您的实际任务。第一个神经网络的较低层将学习可能被第二个神经网络重复使用的特征检测器[1]。

&emsp; 例如，如果你想建立一个识别面孔的系统，你可能只有几个人的照片，这显然不足以训练一个好的分类器。收集每个人的数百张照片将是不实际的。但是，您可以在互联网上收集大量随机人员的照片，并训练第一个神经网络来检测两张不同的照片是否属于同一个人。这样的网络将学习面部优秀的特征检测器，所以重复使用它的较低层将允许你使用很少的训练数据来训练一个好的面部分类器[1]。

&emsp; 收集没有标签的训练样本通常是相当便宜的，但标注它们却相当昂贵。 在这种情况下，一种常见的技术是将所有训练样例标记为“好”，然后通过破坏好的训练样例产生许多新的训练样例，并将这些样例标记为“坏”。然后，您可以训练第一个神经网络 将实例分类为好或不好[1]。

&emsp; 另一种方法是训练第一个网络为每个训练实例输出一个分数，并使用一个损失函数确保一个好的实例的分数大于一个坏实例的分数至少一定的边际。 这被称为最大边际学习[1]。



## 参考文献
[1] [hands_on_Ml_with_Sklearn_and_TF.第10章.训练深层神经网络](https://github.com/apachecn/hands_on_Ml_with_Sklearn_and_TF/blob/dev/docs/11.%E8%AE%AD%E7%BB%83%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.md)
